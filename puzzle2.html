<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Puzzle interactif — La Pizz'À're</title>
  <style>
    html,body {
      height:100%;
      margin:0;
      background:#F5F0E6;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    canvas {
      background:transparent;
      display:block;
      width: 100%;
      height: auto;
      max-width: 600px;
      aspect-ratio: 1/1;
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,.3);
      cursor:grab;
    }
    canvas:active { cursor:grabbing; }
  </style>
</head>
<body>
  <canvas id="puzzleCanvas"></canvas>

<script>
const IMG_SRC = "logo3d.png";
const canvas = document.getElementById('puzzleCanvas');
const ctx = canvas.getContext('2d', { alpha: true });

let img = new Image();
img.src = IMG_SRC;

let pieces = [];
let cols = 4, rows = 4;
let pieceW, pieceH;
let dragging = null, offsetX = 0, offsetY = 0;

function resizeCanvas() {
  const size = Math.min(window.innerWidth, window.innerHeight, 600);
  canvas.width = size;
  canvas.height = size;
}

function buildPieces() {
  pieces = [];
  pieceW = Math.floor(img.width / cols);
  pieceH = Math.floor(img.height / rows);
  for(let r=0;r<rows;r++) {
    for(let c=0;c<cols;c++) {
      const sx = c*pieceW;
      const sy = r*pieceH;
      const sw = (c===cols-1) ? img.width - sx : pieceW;
      const sh = (r===rows-1) ? img.height - sy : pieceH;
      pieces.push({
        sx, sy, sw, sh,
        x: Math.random()*(canvas.width-150),
        y: Math.random()*(canvas.height-150),
        tx: c*(canvas.width/cols),
        ty: r*(canvas.height/rows),
        w: canvas.width/cols,
        h: canvas.height/rows,
        placed:false
      });
    }
  }
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(const p of pieces) {
    ctx.drawImage(img, p.sx, p.sy, p.sw, p.sh, p.x, p.y, p.w, p.h);
    if(!p.placed) {
      ctx.strokeStyle = "rgba(0,0,0,.2)";
      ctx.strokeRect(p.x, p.y, p.w, p.h);
    }
  }
}

function isInside(piece, mx, my) {
  return mx>piece.x && mx<piece.x+piece.w && my>piece.y && my<piece.y+piece.h;
}

function onPointerDown(e) {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.touches? e.touches[0].clientX: e.clientX) - rect.left;
  const my = (e.touches? e.touches[0].clientY: e.clientY) - rect.top;
  for(let i=pieces.length-1;i>=0;i--){
    const p=pieces[i];
    if(isInside(p,mx,my) && !p.placed){
      dragging=p;
      offsetX=mx-p.x;
      offsetY=my-p.y;
      pieces.splice(i,1);
      pieces.unshift(p); // On place les pièces actives au-dessus
      break;
    }
  }
}

function onPointerMove(e) {
  if(dragging){
    const rect = canvas.getBoundingClientRect();
    const mx = (e.touches? e.touches[0].clientX: e.clientX) - rect.left;
    const my = (e.touches? e.touches[0].clientY: e.clientY) - rect.top;
    dragging.x = mx-offsetX;
    dragging.y = my-offsetY;
    draw();
  }
}

function onPointerUp() {
  if(dragging){
    if(Math.abs(dragging.x-dragging.tx)<20 && Math.abs(dragging.y-dragging.ty)<20){
      dragging.x = dragging.tx;
      dragging.y = dragging.ty;
      dragging.placed = true;

      // ✅ Pièce placée envoyée derrière les autres
      const index = pieces.indexOf(dragging);
      if (index > -1) {
        const donePiece = pieces.splice(index,1)[0];
        pieces.push(donePiece);
      }
    }
    dragging=null;
    draw();
  }
}

canvas.addEventListener("mousedown", onPointerDown);
canvas.addEventListener("mousemove", onPointerMove);
canvas.addEventListener("mouseup", onPointerUp);
canvas.addEventListener("touchstart", onPointerDown, {passive:false});
canvas.addEventListener("touchmove", onPointerMove, {passive:false});
canvas.addEventListener("touchend", onPointerUp);

img.onload = ()=>{
  resizeCanvas();
  buildPieces();
  draw();
};

window.addEventListener("resize", ()=>{
  resizeCanvas();
  buildPieces();
  draw();
});
</script>
</body>
</html>
