<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Puzzle interactif — La Pizz'À're</title>
  <style>
    html,body {
      height:100%;
      margin:0;
      background:#F5F0E6;
      display:block;
      align-items:center;
      justify-content:center;
    }
    canvas {
      background:transparent;
      display:block;
      width: 100%;
      height: auto;
      max-width: 600px;
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,.3);
      cursor:grab;
    }
    canvas:active { cursor:grabbing; }
  </style>
</head>
<body>
  <canvas id="puzzleCanvas"></canvas>

<script>
const IMG_SRC = "logo3d.png";
const canvas = document.getElementById('puzzleCanvas');
const ctx = canvas.getContext('2d', { alpha: true });

let img = new Image();
img.src = IMG_SRC;

let pieces = [];
let cols = 4, rows = 4;
let pieceW, pieceH;
let dragging = null, offsetX = 0, offsetY = 0;

function buildPieces() {
  pieces = [];
  pieceW = Math.floor(img.width / cols);
  pieceH = Math.floor(img.height / rows);
  for(let r=0;r<rows;r++) {
    for(let c=0;c<cols;c++) {
      const sx = c*pieceW;
      const sy = r*pieceH;
      const sw = (c===cols-1) ? img.width - sx : pieceW;
      const sh = (r===rows-1) ? img.height - sy : pieceH;

      const targetW = canvas.width/cols;
      const targetH = canvas.height/rows;

      pieces.push({
        sx, sy, sw, sh,
        // ✅ Apparition toujours dans la zone visible
        x: Math.random() * (canvas.width - targetW),
        y: Math.random() * (canvas.height - targetH),
        tx: c * targetW,
        ty: r * targetH,
        w: targetW,
        h: targetH,
        placed:false
      });
    }
  }
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(const p of pieces) {
    ctx.drawImage(img, p.sx, p.sy, p.sw, p.sh, p.x, p.y, p.w, p.h);
    if(!p.placed) {
      ctx.strokeStyle = "rgba(0,0,0,.2)";
      ctx.strokeRect(p.x, p.y, p.w, p.h);
    }
  }
}

function isInside(piece, mx, my) {
  return mx>piece.x && mx<piece.x+piece.w && my>piece.y && my<piece.y+piece.h;
}

// ✅ Empêche la sortie du canvas
function clampPiece(p) {
  p.x = Math.max(0, Math.min(p.x, canvas.width - p.w));
  p.y = Math.max(0, Math.min(p.y, canvas.height - p.h));
}

// ---- Souris ----
canvas.addEventListener("mousedown", e=>{
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  for(let i=pieces.length-1;i>=0;i--){
    const p=pieces[i];
    if(isInside(p,mx,my) && !p.placed){
      dragging=p;
      offsetX=mx-p.x;
      offsetY=my-p.y;
      pieces.splice(i,1);
      pieces.push(p);
      break;
    }
  }
});

canvas.addEventListener("mousemove", e=>{
  if(dragging){
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    dragging.x = mx-offsetX;
    dragging.y = my-offsetY;
    clampPiece(dragging);
    draw();
  }
});

canvas.addEventListener("mouseup", ()=>{
  if(dragging){
    if(Math.abs(dragging.x-dragging.tx)<20 && Math.abs(dragging.y-dragging.ty)<20){
      dragging.x = dragging.tx;
      dragging.y = dragging.ty;
      dragging.placed = true;
    }
    dragging=null;
    draw();
  }
});

// ---- Événements tactiles ----
canvas.addEventListener("touchstart", e=>{
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const mx = touch.clientX - rect.left;
  const my = touch.clientY - rect.top;
  for(let i=pieces.length-1;i>=0;i--){
    const p=pieces[i];
    if(isInside(p,mx,my) && !p.placed){
      dragging=p;
      offsetX=mx-p.x;
      offsetY=my-p.y;
      pieces.splice(i,1);
      pieces.push(p);
      break;
    }
  }
});

canvas.addEventListener("touchmove", e=>{
  if(dragging){
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const mx = touch.clientX - rect.left;
    const my = touch.clientY - rect.top;
    dragging.x = mx-offsetX;
    dragging.y = my-offsetY;
    clampPiece(dragging);
    draw();
  }
}, { passive: false });

canvas.addEventListener("touchend", ()=>{
  if(dragging){
    if(Math.abs(dragging.x-dragging.tx)<20 && Math.abs(dragging.y-dragging.ty)<20){
      dragging.x = dragging.tx;
      dragging.y = dragging.ty;
      dragging.placed = true;
    }
    dragging=null;
    draw();
  }
});

img.onload = ()=>{
  const size = Math.min(window.innerWidth, window.innerHeight, 600);
  canvas.width = size;
  canvas.height = size;
  canvas.style.width = size + "px";
  canvas.style.height = size + "px";

  buildPieces();
  draw();
};
</script>
</body>
</html>
